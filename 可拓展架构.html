<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 8 可拓展架构 | 深入浅出架构</title>
  <meta name="description" content="深入浅出的讲解什么是架构" />
  <meta name="generator" content="bookdown 0.38 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 8 可拓展架构 | 深入浅出架构" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="深入浅出的讲解什么是架构" />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 8 可拓展架构 | 深入浅出架构" />
  
  <meta name="twitter:description" content="深入浅出的讲解什么是架构" />
  

<meta name="author" content="Liam" />


<meta name="date" content="2024-11-16" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="高可用存储架构.html"/>
<link rel="next" href="架构模版.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>



<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">这是一本讲架构的书籍</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> bibliography: [book.bib, packages.bib]</a>
<ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#系统与子系统"><i class="fa fa-check"></i><b>1.1</b> 系统与子系统</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="index.html"><a href="index.html#系统和子系统的定义"><i class="fa fa-check"></i><b>1.1.1</b> <strong>系统和子系统的定义</strong></a></li>
<li class="chapter" data-level="1.1.2" data-path="index.html"><a href="index.html#系统和子系统的关系"><i class="fa fa-check"></i><b>1.1.2</b> <strong>系统和子系统的关系</strong></a></li>
<li class="chapter" data-level="1.1.3" data-path="index.html"><a href="index.html#举例说明"><i class="fa fa-check"></i><b>1.1.3</b> <strong>举例说明</strong></a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#模块与组件"><i class="fa fa-check"></i><b>1.2</b> 模块与组件</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="index.html"><a href="index.html#模块与组件的区别从抽象到实际"><i class="fa fa-check"></i><b>1.2.1</b> 模块与组件的区别：从抽象到实际</a></li>
<li class="chapter" data-level="1.2.2" data-path="index.html"><a href="index.html#维基百科的定义"><i class="fa fa-check"></i><b>1.2.2</b> 维基百科的定义</a></li>
<li class="chapter" data-level="1.2.3" data-path="index.html"><a href="index.html#模块与组件的核心区别"><i class="fa fa-check"></i><b>1.2.3</b> 模块与组件的核心区别</a></li>
<li class="chapter" data-level="1.2.4" data-path="index.html"><a href="index.html#形象的理解模块-vs.-组件"><i class="fa fa-check"></i><b>1.2.4</b> 形象的理解：模块 vs. 组件</a></li>
<li class="chapter" data-level="1.2.5" data-path="index.html"><a href="index.html#示例分析学生信息管理系统"><i class="fa fa-check"></i><b>1.2.5</b> 示例分析：学生信息管理系统</a></li>
<li class="chapter" data-level="1.2.6" data-path="index.html"><a href="index.html#实际应用模块和组件如何协同"><i class="fa fa-check"></i><b>1.2.6</b> 实际应用：模块和组件如何协同？</a></li>
<li class="chapter" data-level="1.2.7" data-path="index.html"><a href="index.html#总结"><i class="fa fa-check"></i><b>1.2.7</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#框架与架构"><i class="fa fa-check"></i><b>1.3</b> 框架与架构</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="index.html"><a href="index.html#框架与架构定义与区别"><i class="fa fa-check"></i><b>1.3.1</b> 框架与架构：定义与区别</a></li>
<li class="chapter" data-level="1.3.2" data-path="index.html"><a href="index.html#框架framework的定义与特点"><i class="fa fa-check"></i><b>1.3.2</b> <strong>框架（Framework）的定义与特点</strong></a></li>
<li class="chapter" data-level="1.3.3" data-path="index.html"><a href="index.html#架构architecture的定义与特点"><i class="fa fa-check"></i><b>1.3.3</b> <strong>架构（Architecture）的定义与特点</strong></a></li>
<li class="chapter" data-level="1.3.4" data-path="index.html"><a href="index.html#框架-vs.-架构"><i class="fa fa-check"></i><b>1.3.4</b> <strong>框架 vs. 架构</strong></a></li>
<li class="chapter" data-level="1.3.5" data-path="index.html"><a href="index.html#混用与实际说法的误区"><i class="fa fa-check"></i><b>1.3.5</b> <strong>混用与实际说法的误区</strong></a></li>
<li class="chapter" data-level="1.3.6" data-path="index.html"><a href="index.html#结合示例模块与组件的延展"><i class="fa fa-check"></i><b>1.3.6</b> <strong>结合示例：模块与组件的延展</strong></a></li>
<li class="chapter" data-level="1.3.7" data-path="index.html"><a href="index.html#总结-1"><i class="fa fa-check"></i><b>1.3.7</b> <strong>总结</strong></a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html#r架构"><i class="fa fa-check"></i><b>1.4</b> 4R架构</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="架构设计历史.html"><a href="架构设计历史.html"><i class="fa fa-check"></i><b>2</b> 架构设计历史</a>
<ul>
<li class="chapter" data-level="2.1" data-path="架构设计历史.html"><a href="架构设计历史.html#机器语言1940年之前"><i class="fa fa-check"></i><b>2.1</b> 机器语言（1940年之前）</a></li>
<li class="chapter" data-level="2.2" data-path="架构设计历史.html"><a href="架构设计历史.html#汇编语言20世纪40年代"><i class="fa fa-check"></i><b>2.2</b> 汇编语言（20世纪40年代）</a></li>
<li class="chapter" data-level="2.3" data-path="架构设计历史.html"><a href="架构设计历史.html#高级语言20世纪50年代"><i class="fa fa-check"></i><b>2.3</b> 高级语言（20世纪50年代）</a></li>
<li class="chapter" data-level="2.4" data-path="架构设计历史.html"><a href="架构设计历史.html#第一次软件危机与结构化程序设计20世纪60年代20世纪70年代"><i class="fa fa-check"></i><b>2.4</b> 第一次软件危机与结构化程序设计（20世纪60年代~20世纪70年代）</a></li>
<li class="chapter" data-level="2.5" data-path="架构设计历史.html"><a href="架构设计历史.html#第二次软件危机与面向对象20世纪80年代"><i class="fa fa-check"></i><b>2.5</b> 第二次软件危机与面向对象（20世纪80年代）</a></li>
<li class="chapter" data-level="2.6" data-path="架构设计历史.html"><a href="架构设计历史.html#软件架构的历史背景"><i class="fa fa-check"></i><b>2.6</b> 软件架构的历史背景</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html"><i class="fa fa-check"></i><b>3</b> 架构设计的真正目的</a>
<ul>
<li class="chapter" data-level="3.1" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#高性能"><i class="fa fa-check"></i><b>3.1</b> 高性能</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#单机复杂度"><i class="fa fa-check"></i><b>3.1.1</b> 单机复杂度</a></li>
<li class="chapter" data-level="3.1.2" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#集群的复杂度"><i class="fa fa-check"></i><b>3.1.2</b> 集群的复杂度</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#高可用"><i class="fa fa-check"></i><b>3.2</b> 高可用</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#计算高可用"><i class="fa fa-check"></i><b>3.2.1</b> 计算高可用</a></li>
<li class="chapter" data-level="3.2.2" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#存储高可用"><i class="fa fa-check"></i><b>3.2.2</b> 存储高可用</a></li>
<li class="chapter" data-level="3.2.3" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#高可用状态决策"><i class="fa fa-check"></i><b>3.2.3</b> 高可用状态决策</a></li>
<li class="chapter" data-level="3.2.4" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#高性能high-performance"><i class="fa fa-check"></i><b>3.2.4</b> 高性能（High Performance）</a></li>
<li class="chapter" data-level="3.2.5" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#高可用high-availability"><i class="fa fa-check"></i><b>3.2.5</b> 高可用（High Availability）</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#可拓展性"><i class="fa fa-check"></i><b>3.3</b> 可拓展性</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#预测变化"><i class="fa fa-check"></i><b>3.3.1</b> 预测变化</a></li>
<li class="chapter" data-level="3.3.2" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#年法则"><i class="fa fa-check"></i><b>3.3.2</b> 2年法则</a></li>
<li class="chapter" data-level="3.3.3" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#应对变化"><i class="fa fa-check"></i><b>3.3.3</b> 应对变化</a></li>
<li class="chapter" data-level="3.3.4" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#写2抄3重构原则"><i class="fa fa-check"></i><b>3.3.4</b> 1写2抄3重构原则</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#成本与安全"><i class="fa fa-check"></i><b>3.4</b> 成本与安全</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#成本"><i class="fa fa-check"></i><b>3.4.1</b> 成本</a></li>
<li class="chapter" data-level="3.4.2" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#安全"><i class="fa fa-check"></i><b>3.4.2</b> 安全</a></li>
<li class="chapter" data-level="3.4.3" data-path="架构设计的真正目的.html"><a href="架构设计的真正目的.html#规模"><i class="fa fa-check"></i><b>3.4.3</b> 规模</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="架构设计的原则.html"><a href="架构设计的原则.html"><i class="fa fa-check"></i><b>4</b> 架构设计的原则</a>
<ul>
<li class="chapter" data-level="4.1" data-path="架构设计的原则.html"><a href="架构设计的原则.html#合适原则"><i class="fa fa-check"></i><b>4.1</b> 合适原则</a></li>
<li class="chapter" data-level="4.2" data-path="架构设计的原则.html"><a href="架构设计的原则.html#简单原则"><i class="fa fa-check"></i><b>4.2</b> 简单原则</a></li>
<li class="chapter" data-level="4.3" data-path="架构设计的原则.html"><a href="架构设计的原则.html#演化原则"><i class="fa fa-check"></i><b>4.3</b> 演化原则</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="架构设计.html"><a href="架构设计.html"><i class="fa fa-check"></i><b>5</b> 架构设计</a>
<ul>
<li class="chapter" data-level="5.1" data-path="架构设计.html"><a href="架构设计.html#识别复杂度"><i class="fa fa-check"></i><b>5.1</b> 识别复杂度</a></li>
<li class="chapter" data-level="5.2" data-path="架构设计.html"><a href="架构设计.html#设计备选方案"><i class="fa fa-check"></i><b>5.2</b> 设计备选方案</a></li>
<li class="chapter" data-level="5.3" data-path="架构设计.html"><a href="架构设计.html#评估和选择备选方案"><i class="fa fa-check"></i><b>5.3</b> 评估和选择备选方案</a></li>
<li class="chapter" data-level="5.4" data-path="架构设计.html"><a href="架构设计.html#详细方案设计"><i class="fa fa-check"></i><b>5.4</b> 详细方案设计</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="高性能架构.html"><a href="高性能架构.html"><i class="fa fa-check"></i><b>6</b> 高性能架构</a>
<ul>
<li class="chapter" data-level="6.1" data-path="高性能架构.html"><a href="高性能架构.html#读写分离原理"><i class="fa fa-check"></i><b>6.1</b> 读写分离原理</a>
<ul>
<li class="chapter" data-level="6.1.1" data-path="高性能架构.html"><a href="高性能架构.html#复制延迟"><i class="fa fa-check"></i><b>6.1.1</b> 复制延迟</a></li>
<li class="chapter" data-level="6.1.2" data-path="高性能架构.html"><a href="高性能架构.html#分配机制"><i class="fa fa-check"></i><b>6.1.2</b> 分配机制</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="高性能架构.html"><a href="高性能架构.html#分库分表"><i class="fa fa-check"></i><b>6.2</b> 分库分表</a>
<ul>
<li class="chapter" data-level="6.2.1" data-path="高性能架构.html"><a href="高性能架构.html#业务分库"><i class="fa fa-check"></i><b>6.2.1</b> 业务分库</a></li>
<li class="chapter" data-level="6.2.2" data-path="高性能架构.html"><a href="高性能架构.html#分表"><i class="fa fa-check"></i><b>6.2.2</b> 分表</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="高性能架构.html"><a href="高性能架构.html#nosql"><i class="fa fa-check"></i><b>6.3</b> NoSQL</a>
<ul>
<li class="chapter" data-level="6.3.1" data-path="高性能架构.html"><a href="高性能架构.html#k-v存储"><i class="fa fa-check"></i><b>6.3.1</b> K-V存储</a></li>
<li class="chapter" data-level="6.3.2" data-path="高性能架构.html"><a href="高性能架构.html#文档数据库"><i class="fa fa-check"></i><b>6.3.2</b> 文档数据库</a></li>
<li class="chapter" data-level="6.3.3" data-path="高性能架构.html"><a href="高性能架构.html#列式数据库"><i class="fa fa-check"></i><b>6.3.3</b> 列式数据库</a></li>
<li class="chapter" data-level="6.3.4" data-path="高性能架构.html"><a href="高性能架构.html#全文搜索引擎"><i class="fa fa-check"></i><b>6.3.4</b> 全文搜索引擎</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="高性能架构.html"><a href="高性能架构.html#缓存"><i class="fa fa-check"></i><b>6.4</b> 缓存</a>
<ul>
<li class="chapter" data-level="6.4.1" data-path="高性能架构.html"><a href="高性能架构.html#缓存穿透"><i class="fa fa-check"></i><b>6.4.1</b> 缓存穿透</a></li>
<li class="chapter" data-level="6.4.2" data-path="高性能架构.html"><a href="高性能架构.html#缓存雪崩"><i class="fa fa-check"></i><b>6.4.2</b> 缓存雪崩</a></li>
<li class="chapter" data-level="6.4.3" data-path="高性能架构.html"><a href="高性能架构.html#缓存热点"><i class="fa fa-check"></i><b>6.4.3</b> 缓存热点</a></li>
</ul></li>
<li class="chapter" data-level="6.5" data-path="高性能架构.html"><a href="高性能架构.html#ppc-和tpc"><i class="fa fa-check"></i><b>6.5</b> PPC 和TPC</a>
<ul>
<li class="chapter" data-level="6.5.1" data-path="高性能架构.html"><a href="高性能架构.html#ppc"><i class="fa fa-check"></i><b>6.5.1</b> PPC</a></li>
<li class="chapter" data-level="6.5.2" data-path="高性能架构.html"><a href="高性能架构.html#prefork"><i class="fa fa-check"></i><b>6.5.2</b> prefork</a></li>
<li class="chapter" data-level="6.5.3" data-path="高性能架构.html"><a href="高性能架构.html#tpc"><i class="fa fa-check"></i><b>6.5.3</b> TPC</a></li>
<li class="chapter" data-level="6.5.4" data-path="高性能架构.html"><a href="高性能架构.html#prethread"><i class="fa fa-check"></i><b>6.5.4</b> prethread</a></li>
</ul></li>
<li class="chapter" data-level="6.6" data-path="高性能架构.html"><a href="高性能架构.html#高效资源利用与事件处理"><i class="fa fa-check"></i><b>6.6</b> 高效资源利用与事件处理</a>
<ul>
<li class="chapter" data-level="6.6.1" data-path="高性能架构.html"><a href="高性能架构.html#为什么阻塞处理低效"><i class="fa fa-check"></i><b>6.6.1</b> 为什么阻塞处理低效？</a></li>
<li class="chapter" data-level="6.6.2" data-path="高性能架构.html"><a href="高性能架构.html#非阻塞轮询优点与局限"><i class="fa fa-check"></i><b>6.6.2</b> 非阻塞轮询：优点与局限</a></li>
<li class="chapter" data-level="6.6.3" data-path="高性能架构.html"><a href="高性能架构.html#io多路复用解决方案"><i class="fa fa-check"></i><b>6.6.3</b> ###I/O多路复用：解决方案</a></li>
<li class="chapter" data-level="6.6.4" data-path="高性能架构.html"><a href="高性能架构.html#reactor-模式"><i class="fa fa-check"></i><b>6.6.4</b> ###Reactor 模式</a></li>
<li class="chapter" data-level="6.6.5" data-path="高性能架构.html"><a href="高性能架构.html#reactor-模式的三种典型实现"><i class="fa fa-check"></i><b>6.6.5</b> ###Reactor 模式的三种典型实现</a></li>
<li class="chapter" data-level="6.6.6" data-path="高性能架构.html"><a href="高性能架构.html#proactor-模式异步io的新高度"><i class="fa fa-check"></i><b>6.6.6</b> ###Proactor 模式：异步I/O的新高度</a></li>
</ul></li>
<li class="chapter" data-level="6.7" data-path="高性能架构.html"><a href="高性能架构.html#高性能集群与负载均衡详解"><i class="fa fa-check"></i><b>6.7</b> 高性能集群与负载均衡详解</a>
<ul>
<li class="chapter" data-level="6.7.1" data-path="高性能架构.html"><a href="高性能架构.html#高性能集群的背景与目标"><i class="fa fa-check"></i><b>6.7.1</b> 高性能集群的背景与目标</a></li>
<li class="chapter" data-level="6.7.2" data-path="高性能架构.html"><a href="高性能架构.html#负载均衡的概念与作用"><i class="fa fa-check"></i><b>6.7.2</b> 负载均衡的概念与作用</a></li>
<li class="chapter" data-level="6.7.3" data-path="高性能架构.html"><a href="高性能架构.html#负载均衡的分类"><i class="fa fa-check"></i><b>6.7.3</b> 负载均衡的分类</a></li>
<li class="chapter" data-level="6.7.4" data-path="高性能架构.html"><a href="高性能架构.html#dns负载均衡"><i class="fa fa-check"></i><b>6.7.4</b> ###DNS负载均衡</a></li>
<li class="chapter" data-level="6.7.5" data-path="高性能架构.html"><a href="高性能架构.html#硬件负载均衡"><i class="fa fa-check"></i><b>6.7.5</b> ###硬件负载均衡</a></li>
<li class="chapter" data-level="6.7.6" data-path="高性能架构.html"><a href="高性能架构.html#软件负载均衡"><i class="fa fa-check"></i><b>6.7.6</b> ###软件负载均衡</a></li>
<li class="chapter" data-level="6.7.7" data-path="高性能架构.html"><a href="高性能架构.html#组合使用负载均衡"><i class="fa fa-check"></i><b>6.7.7</b> ###组合使用负载均衡</a></li>
</ul></li>
<li class="chapter" data-level="6.8" data-path="高性能架构.html"><a href="高性能架构.html#负载均衡算法分类与解析"><i class="fa fa-check"></i><b>6.8</b> 负载均衡算法分类与解析</a>
<ul>
<li class="chapter" data-level="6.8.1" data-path="高性能架构.html"><a href="高性能架构.html#轮询算法"><i class="fa fa-check"></i><b>6.8.1</b> 1. ###轮询算法</a></li>
<li class="chapter" data-level="6.8.2" data-path="高性能架构.html"><a href="高性能架构.html#加权轮询算法"><i class="fa fa-check"></i><b>6.8.2</b> 2. ###加权轮询算法</a></li>
<li class="chapter" data-level="6.8.3" data-path="高性能架构.html"><a href="高性能架构.html#负载最低优先算法"><i class="fa fa-check"></i><b>6.8.3</b> 3. ###负载最低优先算法</a></li>
<li class="chapter" data-level="6.8.4" data-path="高性能架构.html"><a href="高性能架构.html#性能最优类算法"><i class="fa fa-check"></i><b>6.8.4</b> 4. ###性能最优类算法</a></li>
<li class="chapter" data-level="6.8.5" data-path="高性能架构.html"><a href="高性能架构.html#hash类算法"><i class="fa fa-check"></i><b>6.8.5</b> 5. ###Hash类算法</a></li>
</ul></li>
<li class="chapter" data-level="6.9" data-path="高性能架构.html"><a href="高性能架构.html#cap-定理简介"><i class="fa fa-check"></i><b>6.9</b> CAP 定理简介</a>
<ul>
<li class="chapter" data-level="6.9.1" data-path="高性能架构.html"><a href="高性能架构.html#cap-定义的困惑"><i class="fa fa-check"></i><b>6.9.1</b> CAP 定义的困惑</a></li>
<li class="chapter" data-level="6.9.2" data-path="高性能架构.html"><a href="高性能架构.html#cap-定理的两版解释"><i class="fa fa-check"></i><b>6.9.2</b> CAP 定理的两版解释</a></li>
<li class="chapter" data-level="6.9.3" data-path="高性能架构.html"><a href="高性能架构.html#cap-三要素的详细解析"><i class="fa fa-check"></i><b>6.9.3</b> CAP 三要素的详细解析</a></li>
<li class="chapter" data-level="6.9.4" data-path="高性能架构.html"><a href="高性能架构.html#cap-理论的实际应用"><i class="fa fa-check"></i><b>6.9.4</b> CAP 理论的实际应用</a></li>
</ul></li>
<li class="chapter" data-level="6.10" data-path="高性能架构.html"><a href="高性能架构.html#fmea-方法简介"><i class="fa fa-check"></i><b>6.10</b> FMEA 方法简介</a>
<ul>
<li class="chapter" data-level="6.10.1" data-path="高性能架构.html"><a href="高性能架构.html#fmea-方法的具体应用"><i class="fa fa-check"></i><b>6.10.1</b> FMEA 方法的具体应用</a></li>
<li class="chapter" data-level="6.10.2" data-path="高性能架构.html"><a href="高性能架构.html#fmea-实战用户管理系统案例"><i class="fa fa-check"></i><b>6.10.2</b> FMEA 实战：用户管理系统案例</a></li>
<li class="chapter" data-level="6.10.3" data-path="高性能架构.html"><a href="高性能架构.html#总结-2"><i class="fa fa-check"></i><b>6.10.3</b> 总结</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="高可用存储架构.html"><a href="高可用存储架构.html"><i class="fa fa-check"></i><b>7</b> 高可用存储架构</a>
<ul>
<li class="chapter" data-level="7.1" data-path="高可用存储架构.html"><a href="高可用存储架构.html#存储高可用方案"><i class="fa fa-check"></i><b>7.1</b> 存储高可用方案</a>
<ul>
<li class="chapter" data-level="7.1.1" data-path="高可用存储架构.html"><a href="高可用存储架构.html#主备复制架构"><i class="fa fa-check"></i><b>7.1.1</b> 1. 主备复制架构</a></li>
<li class="chapter" data-level="7.1.2" data-path="高可用存储架构.html"><a href="高可用存储架构.html#主从复制架构"><i class="fa fa-check"></i><b>7.1.2</b> 2. 主从复制架构</a></li>
<li class="chapter" data-level="7.1.3" data-path="高可用存储架构.html"><a href="高可用存储架构.html#双机切换架构"><i class="fa fa-check"></i><b>7.1.3</b> 3. 双机切换架构</a></li>
<li class="chapter" data-level="7.1.4" data-path="高可用存储架构.html"><a href="高可用存储架构.html#主主复制架构"><i class="fa fa-check"></i><b>7.1.4</b> 4. 主主复制架构</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="高可用存储架构.html"><a href="高可用存储架构.html#数据集群架构详解"><i class="fa fa-check"></i><b>7.2</b> 数据集群架构详解</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="高可用存储架构.html"><a href="高可用存储架构.html#什么是数据集群"><i class="fa fa-check"></i><b>7.2.1</b> 什么是数据集群？</a></li>
<li class="chapter" data-level="7.2.2" data-path="高可用存储架构.html"><a href="高可用存储架构.html#数据集中集群"><i class="fa fa-check"></i><b>7.2.2</b> 1. 数据集中集群</a></li>
<li class="chapter" data-level="7.2.3" data-path="高可用存储架构.html"><a href="高可用存储架构.html#数据分散集群"><i class="fa fa-check"></i><b>7.2.3</b> 2. 数据分散集群</a></li>
<li class="chapter" data-level="7.2.4" data-path="高可用存储架构.html"><a href="高可用存储架构.html#数据分区"><i class="fa fa-check"></i><b>7.2.4</b> 3. 数据分区</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="高可用存储架构.html"><a href="高可用存储架构.html#计算高可用设计"><i class="fa fa-check"></i><b>7.3</b> 计算高可用设计</a>
<ul>
<li class="chapter" data-level="7.3.1" data-path="高可用存储架构.html"><a href="高可用存储架构.html#关键设计点"><i class="fa fa-check"></i><b>7.3.1</b> 关键设计点</a></li>
<li class="chapter" data-level="7.3.2" data-path="高可用存储架构.html"><a href="高可用存储架构.html#常见的计算高可用架构"><i class="fa fa-check"></i><b>7.3.2</b> 常见的计算高可用架构</a></li>
<li class="chapter" data-level="7.3.3" data-path="高可用存储架构.html"><a href="高可用存储架构.html#总结-3"><i class="fa fa-check"></i><b>7.3.3</b> 总结</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="可拓展架构.html"><a href="可拓展架构.html"><i class="fa fa-check"></i><b>8</b> 可拓展架构</a>
<ul>
<li class="chapter" data-level="8.1" data-path="可拓展架构.html"><a href="可拓展架构.html#软件系统的可扩展性核心理念与实现"><i class="fa fa-check"></i><b>8.1</b> 软件系统的可扩展性：核心理念与实现</a>
<ul>
<li class="chapter" data-level="8.1.1" data-path="可拓展架构.html"><a href="可拓展架构.html#可扩展性的核心挑战"><i class="fa fa-check"></i><b>8.1.1</b> 可扩展性的核心挑战</a></li>
<li class="chapter" data-level="8.1.2" data-path="可拓展架构.html"><a href="可拓展架构.html#可扩展性的基本思想拆分"><i class="fa fa-check"></i><b>8.1.2</b> 可扩展性的基本思想：拆分</a></li>
<li class="chapter" data-level="8.1.3" data-path="可拓展架构.html"><a href="可拓展架构.html#三种常见的拆分思路"><i class="fa fa-check"></i><b>8.1.3</b> 三种常见的拆分思路</a></li>
<li class="chapter" data-level="8.1.4" data-path="可拓展架构.html"><a href="可拓展架构.html#案例解析tcpip-协议栈"><i class="fa fa-check"></i><b>8.1.4</b> 案例解析：TCP/IP 协议栈</a></li>
<li class="chapter" data-level="8.1.5" data-path="可拓展架构.html"><a href="可拓展架构.html#案例解析学生信息管理系统"><i class="fa fa-check"></i><b>8.1.5</b> 案例解析：学生信息管理系统</a></li>
<li class="chapter" data-level="8.1.6" data-path="可拓展架构.html"><a href="可拓展架构.html#拆分方式的影响可扩展性"><i class="fa fa-check"></i><b>8.1.6</b> 拆分方式的影响：可扩展性</a></li>
<li class="chapter" data-level="8.1.7" data-path="可拓展架构.html"><a href="可拓展架构.html#常见可扩展架构"><i class="fa fa-check"></i><b>8.1.7</b> 常见可扩展架构</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="可拓展架构.html"><a href="可拓展架构.html#分层架构"><i class="fa fa-check"></i><b>8.2</b> 分层架构</a>
<ul>
<li class="chapter" data-level="8.2.1" data-path="可拓展架构.html"><a href="可拓展架构.html#分层架构的多样性"><i class="fa fa-check"></i><b>8.2.1</b> 分层架构的多样性</a></li>
<li class="chapter" data-level="8.2.2" data-path="可拓展架构.html"><a href="可拓展架构.html#分层架构的设计核心"><i class="fa fa-check"></i><b>8.2.2</b> 分层架构的设计核心</a></li>
<li class="chapter" data-level="8.2.3" data-path="可拓展架构.html"><a href="可拓展架构.html#分层架构的优势"><i class="fa fa-check"></i><b>8.2.3</b> 分层架构的优势</a></li>
<li class="chapter" data-level="8.2.4" data-path="可拓展架构.html"><a href="可拓展架构.html#分层架构的局限性"><i class="fa fa-check"></i><b>8.2.4</b> 分层架构的局限性</a></li>
</ul></li>
<li class="chapter" data-level="8.3" data-path="可拓展架构.html"><a href="可拓展架构.html#soa面向服务架构"><i class="fa fa-check"></i><b>8.3</b> SOA（面向服务架构）</a>
<ul>
<li class="chapter" data-level="8.3.1" data-path="可拓展架构.html"><a href="可拓展架构.html#soa-的核心概念"><i class="fa fa-check"></i><b>8.3.1</b> SOA 的核心概念</a></li>
<li class="chapter" data-level="8.3.2" data-path="可拓展架构.html"><a href="可拓展架构.html#soa-的优势"><i class="fa fa-check"></i><b>8.3.2</b> SOA 的优势</a></li>
<li class="chapter" data-level="8.3.3" data-path="可拓展架构.html"><a href="可拓展架构.html#soa-的挑战"><i class="fa fa-check"></i><b>8.3.3</b> SOA 的挑战</a></li>
<li class="chapter" data-level="8.3.4" data-path="可拓展架构.html"><a href="可拓展架构.html#soa-的典型架构"><i class="fa fa-check"></i><b>8.3.4</b> SOA 的典型架构</a></li>
<li class="chapter" data-level="8.3.5" data-path="可拓展架构.html"><a href="可拓展架构.html#soa-的局限性"><i class="fa fa-check"></i><b>8.3.5</b> SOA 的局限性</a></li>
</ul></li>
<li class="chapter" data-level="8.4" data-path="可拓展架构.html"><a href="可拓展架构.html#微服务炙手可热的架构设计理念"><i class="fa fa-check"></i><b>8.4</b> 微服务：炙手可热的架构设计理念</a>
<ul>
<li class="chapter" data-level="8.4.1" data-path="可拓展架构.html"><a href="可拓展架构.html#微服务与-soa-的关系"><i class="fa fa-check"></i><b>8.4.1</b> 微服务与 SOA 的关系</a></li>
<li class="chapter" data-level="8.4.2" data-path="可拓展架构.html"><a href="可拓展架构.html#soa-与微服务的主要区别"><i class="fa fa-check"></i><b>8.4.2</b> SOA 与微服务的主要区别</a></li>
<li class="chapter" data-level="8.4.3" data-path="可拓展架构.html"><a href="可拓展架构.html#微服务的陷阱与挑战"><i class="fa fa-check"></i><b>8.4.3</b> 微服务的陷阱与挑战</a></li>
<li class="chapter" data-level="8.4.4" data-path="可拓展架构.html"><a href="可拓展架构.html#总结-4"><i class="fa fa-check"></i><b>8.4.4</b> 总结</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="架构模版.html"><a href="架构模版.html"><i class="fa fa-check"></i><b>9</b> 架构模版</a>
<ul>
<li class="chapter" data-level="9.1" data-path="架构模版.html"><a href="架构模版.html#存储技术架构"><i class="fa fa-check"></i><b>9.1</b> 存储技术架构</a>
<ul>
<li class="chapter" data-level="9.1.1" data-path="架构模版.html"><a href="架构模版.html#sql"><i class="fa fa-check"></i><b>9.1.1</b> SQL</a></li>
<li class="chapter" data-level="9.1.2" data-path="架构模版.html"><a href="架构模版.html#nosql-1"><i class="fa fa-check"></i><b>9.1.2</b> NoSQL</a></li>
<li class="chapter" data-level="9.1.3" data-path="架构模版.html"><a href="架构模版.html#小文件存储"><i class="fa fa-check"></i><b>9.1.3</b> 小文件存储</a></li>
<li class="chapter" data-level="9.1.4" data-path="架构模版.html"><a href="架构模版.html#大文件存储"><i class="fa fa-check"></i><b>9.1.4</b> 大文件存储</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="架构模版.html"><a href="架构模版.html#开发层和服务层技术"><i class="fa fa-check"></i><b>9.2</b> 开发层和服务层技术</a>
<ul>
<li class="chapter" data-level="9.2.1" data-path="架构模版.html"><a href="架构模版.html#开发层技术"><i class="fa fa-check"></i><b>9.2.1</b> 开发层技术</a></li>
<li class="chapter" data-level="9.2.2" data-path="架构模版.html"><a href="架构模版.html#开发框架"><i class="fa fa-check"></i><b>9.2.2</b> 开发框架</a></li>
<li class="chapter" data-level="9.2.3" data-path="架构模版.html"><a href="架构模版.html#服务层技术"><i class="fa fa-check"></i><b>9.2.3</b> 服务层技术</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="架构模版.html"><a href="架构模版.html#网络层技术"><i class="fa fa-check"></i><b>9.3</b> 网络层技术</a>
<ul>
<li class="chapter" data-level="9.3.1" data-path="架构模版.html"><a href="架构模版.html#负载均衡"><i class="fa fa-check"></i><b>9.3.1</b> 负载均衡</a></li>
<li class="chapter" data-level="9.3.2" data-path="架构模版.html"><a href="架构模版.html#cdn"><i class="fa fa-check"></i><b>9.3.2</b> CDN</a></li>
<li class="chapter" data-level="9.3.3" data-path="架构模版.html"><a href="架构模版.html#多机房"><i class="fa fa-check"></i><b>9.3.3</b> 多机房</a></li>
<li class="chapter" data-level="9.3.4" data-path="架构模版.html"><a href="架构模版.html#多中心"><i class="fa fa-check"></i><b>9.3.4</b> 多中心</a></li>
</ul></li>
<li class="chapter" data-level="9.4" data-path="架构模版.html"><a href="架构模版.html#用户层和业务层技术"><i class="fa fa-check"></i><b>9.4</b> 用户层和业务层技术</a>
<ul>
<li class="chapter" data-level="9.4.1" data-path="架构模版.html"><a href="架构模版.html#用户层技术"><i class="fa fa-check"></i><b>9.4.1</b> 用户层技术</a></li>
<li class="chapter" data-level="9.4.2" data-path="架构模版.html"><a href="架构模版.html#业务层技术"><i class="fa fa-check"></i><b>9.4.2</b> 业务层技术</a></li>
</ul></li>
<li class="chapter" data-level="9.5" data-path="架构模版.html"><a href="架构模版.html#平台技术"><i class="fa fa-check"></i><b>9.5</b> 平台技术</a>
<ul>
<li class="chapter" data-level="9.5.1" data-path="架构模版.html"><a href="架构模版.html#运维平台"><i class="fa fa-check"></i><b>9.5.1</b> 运维平台</a></li>
<li class="chapter" data-level="9.5.2" data-path="架构模版.html"><a href="架构模版.html#测试平台"><i class="fa fa-check"></i><b>9.5.2</b> 测试平台</a></li>
<li class="chapter" data-level="9.5.3" data-path="架构模版.html"><a href="架构模版.html#数据平台"><i class="fa fa-check"></i><b>9.5.3</b> 数据平台</a></li>
<li class="chapter" data-level="9.5.4" data-path="架构模版.html"><a href="架构模版.html#管理平台"><i class="fa fa-check"></i><b>9.5.4</b> 管理平台</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="架构设计模版.html"><a href="架构设计模版.html"><i class="fa fa-check"></i><b>10</b> 架构设计模版</a>
<ul>
<li class="chapter" data-level="10.1" data-path="架构设计模版.html"><a href="架构设计模版.html#备选方案模板优化版"><i class="fa fa-check"></i><b>10.1</b> <strong>备选方案模板优化版</strong></a>
<ul>
<li class="chapter" data-level="10.1.1" data-path="架构设计模版.html"><a href="架构设计模版.html#需求介绍"><i class="fa fa-check"></i><b>10.1.1</b> ** 需求介绍**</a></li>
<li class="chapter" data-level="10.1.2" data-path="架构设计模版.html"><a href="架构设计模版.html#需求分析"><i class="fa fa-check"></i><b>10.1.2</b> ** 需求分析**</a></li>
<li class="chapter" data-level="10.1.3" data-path="架构设计模版.html"><a href="架构设计模版.html#复杂度分析"><i class="fa fa-check"></i><b>10.1.3</b> ** 复杂度分析**</a></li>
<li class="chapter" data-level="10.1.4" data-path="架构设计模版.html"><a href="架构设计模版.html#备选方案"><i class="fa fa-check"></i><b>10.1.4</b> ** 备选方案**</a></li>
<li class="chapter" data-level="10.1.5" data-path="架构设计模版.html"><a href="架构设计模版.html#备选方案评估"><i class="fa fa-check"></i><b>10.1.5</b> ** 备选方案评估**</a></li>
<li class="chapter" data-level="10.1.6" data-path="架构设计模版.html"><a href="架构设计模版.html#最终架构设计"><i class="fa fa-check"></i><b>10.1.6</b> ** 最终架构设计**</a></li>
<li class="chapter" data-level="10.1.7" data-path="架构设计模版.html"><a href="架构设计模版.html#核心设计与流程"><i class="fa fa-check"></i><b>10.1.7</b> <strong>核心设计与流程</strong></a></li>
<li class="chapter" data-level="10.1.8" data-path="架构设计模版.html"><a href="架构设计模版.html#部署方案"><i class="fa fa-check"></i><b>10.1.8</b> <strong>部署方案</strong></a></li>
<li class="chapter" data-level="10.1.9" data-path="架构设计模版.html"><a href="架构设计模版.html#演进规划"><i class="fa fa-check"></i><b>10.1.9</b> <strong>演进规划</strong></a></li>
<li class="chapter" data-level="10.1.10" data-path="架构设计模版.html"><a href="架构设计模版.html#总结-5"><i class="fa fa-check"></i><b>10.1.10</b> <strong>总结</strong></a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="架构设计模版.html"><a href="架构设计模版.html#话架构图"><i class="fa fa-check"></i><b>10.2</b> 话架构图</a>
<ul>
<li class="chapter" data-level="10.2.1" data-path="架构设计模版.html"><a href="架构设计模版.html#视图软件架构的经典模型"><i class="fa fa-check"></i><b>10.2.1</b> <strong>4+1 视图：软件架构的经典模型</strong></a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/liamamilin" target="blank">这是一本讲架构的书籍</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">深入浅出架构</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="可拓展架构" class="section level1 hasAnchor" number="8">
<h1><span class="header-section-number">Chapter 8</span> 可拓展架构<a href="可拓展架构.html#可拓展架构" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="软件系统的可扩展性核心理念与实现" class="section level2 hasAnchor" number="8.1">
<h2><span class="header-section-number">8.1</span> 软件系统的可扩展性：核心理念与实现<a href="可拓展架构.html#软件系统的可扩展性核心理念与实现" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>相比硬件和建筑系统，软件系统的最大特性在于其可扩展性。硬件和建筑系统在完成制造或建造后，其整体结构和功能基本固定，例如，CPU一旦生产出来安装到PC中，就不会再返回工厂增加新功能；金字塔矗立千年，其结构从建成之日起便未曾改变。而软件系统完全不同，如果一个软件系统开发完成后从未经历任何更新和调整，则很可能意味着该系统已经停滞、不具备生命力。真正成功的软件系统，往往是随着需求变化和技术进步而不断迭代发展的。例如，从 Windows 3.0 到 Windows XP 再到 Windows 10，每一代操作系统都融入了新的特性，以适应时代需求。</p>
<hr />
<div id="可扩展性的核心挑战" class="section level3 hasAnchor" number="8.1.1">
<h3><span class="header-section-number">8.1.1</span> 可扩展性的核心挑战<a href="可拓展架构.html#可扩展性的核心挑战" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>软件系统的这种内在可扩展性，既是其魅力所在，也是设计的难点所在。<br />
- 魅力在于，软件可以通过不断修改与扩展，满足新的业务需求或技术趋势。<br />
- 难点在于，如何以最小的代价实现扩展。很多情况下，扩展过程中可能导致“牵一发而动全身”，需要对系统的多个部分进行大范围修改，甚至可能推倒重来。<br />
这种情况带来的风险显而易见：改动范围越大，投入越多，出错的可能性也越高。因此，如何在扩展时尽可能缩小改动范围并降低风险，是软件架构可扩展性设计的核心目标。</p>
<hr />
</div>
<div id="可扩展性的基本思想拆分" class="section level3 hasAnchor" number="8.1.2">
<h3><span class="header-section-number">8.1.2</span> 可扩展性的基本思想：拆分<a href="可拓展架构.html#可扩展性的基本思想拆分" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>可扩展性架构的设计方法有很多，但它们的核心思想可以归结为一个字：拆。<br />
- 拆分是将原本统一的大系统分解为多个较小的部分，使得扩展时只需修改其中一部分，无需改动整个系统，从而减少风险和复杂性。</p>
<p>然而，软件系统的“拆分”与现实中的拆分截然不同。现实中的拆分往往是破坏性的，例如用推土机拆房子、用剪刀拆包装袋，而软件系统的拆分是建设性的。拆分后的系统必须更高效、更灵活，且具备更好的可扩展性，这种设计显然更为复杂。</p>
<hr />
</div>
<div id="三种常见的拆分思路" class="section level3 hasAnchor" number="8.1.3">
<h3><span class="header-section-number">8.1.3</span> 三种常见的拆分思路<a href="可拓展架构.html#三种常见的拆分思路" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>根据不同的设计思路，可以将软件系统按照以下三种方式拆分：</p>
<ol style="list-style-type: decimal">
<li>面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一个独立部分。<br />
</li>
<li>面向服务拆分：将系统提供的服务进行拆分，每个服务作为一个独立部分。<br />
</li>
<li>面向功能拆分：将系统的具体功能模块进行拆分，每个功能模块作为一个独立部分。</li>
</ol>
<p>理解这三种思路的关键在于理清“流程”“服务”“功能”三者的关系。从范围来看，它们的规模依次缩小：流程 &gt; 服务 &gt; 功能。通过以下案例可以更直观地理解它们的区别。</p>
<hr />
</div>
<div id="案例解析tcpip-协议栈" class="section level3 hasAnchor" number="8.1.4">
<h3><span class="header-section-number">8.1.4</span> 案例解析：TCP/IP 协议栈<a href="可拓展架构.html#案例解析tcpip-协议栈" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>以 TCP/IP 协议栈为例：</p>
<ol style="list-style-type: decimal">
<li><p>流程拆分：<br />
对应 TCP/IP 的四层模型（应用层 → 传输层 → 网络层 → 物理+数据链路层），通信的流程是固定的，每层负责不同阶段的任务。</p></li>
<li><p>服务拆分：<br />
对应应用层的具体协议，如 HTTP、FTP、SMTP 等服务。每种协议提供不同的服务，HTTP 提供网页服务，FTP 提供文件传输服务，SMTP 提供邮件服务。</p></li>
<li><p>功能拆分：<br />
每种服务再细分为不同的功能。例如，HTTP 服务包括 GET 和 POST 请求，FTP 服务包括上传和下载功能，SMTP 服务包括邮件发送和接收功能。</p></li>
</ol>
<hr />
</div>
<div id="案例解析学生信息管理系统" class="section level3 hasAnchor" number="8.1.5">
<h3><span class="header-section-number">8.1.5</span> 案例解析：学生信息管理系统<a href="可拓展架构.html#案例解析学生信息管理系统" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>另以一个常见的学生信息管理系统为例，展示三种拆分方式：</p>
<ol style="list-style-type: decimal">
<li><p>面向流程拆分<br />
将系统按照逻辑层次划分为：展示层 → 业务层 → 数据层 → 存储层。</p>
<ul>
<li>展示层：负责用户界面的设计，如登录页面、注册页面等。<br />
</li>
<li>业务层：负责业务逻辑的处理，如注册、登录等操作。<br />
</li>
<li>数据层：负责数据访问操作，如增删改查数据库。<br />
</li>
<li>存储层：负责数据存储，如使用 MySQL 或 Redis。<br />
架构示意图：<br />
</li>
</ul>
<pre><code>展示层 ——&gt; 业务层 ——&gt; 数据层 ——&gt; 存储层</code></pre></li>
<li><p>面向服务拆分<br />
将系统按照服务拆分为：注册服务、登录服务、信息管理服务、安全设置服务等。<br />
架构示意图：</p>
<pre><code>注册服务 ——&gt; 登录服务 ——&gt; 信息管理服务 ——&gt; 安全设置服务</code></pre></li>
<li><p>面向功能拆分<br />
将每个服务进一步拆分为细粒度的功能模块。例如：</p>
<ul>
<li>注册服务：拆分为手机号注册、邮箱注册等功能。<br />
</li>
<li>登录服务：拆分为手机号登录、邮箱登录等功能。<br />
</li>
<li>信息管理服务：拆分为课程管理、成绩管理等功能。<br />
架构示意图：<br />
</li>
</ul>
<pre><code>注册服务（手机号注册 + 邮箱注册）  
登录服务（手机号登录 + 邮箱登录）  
信息管理服务（课程管理 + 成绩管理）</code></pre></li>
</ol>
<hr />
</div>
<div id="拆分方式的影响可扩展性" class="section level3 hasAnchor" number="8.1.6">
<h3><span class="header-section-number">8.1.6</span> 拆分方式的影响：可扩展性<a href="可拓展架构.html#拆分方式的影响可扩展性" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>不同的拆分方式决定了系统的扩展方式。合理的拆分可以降低扩展成本并减少出错风险，具体优势如下：</p>
<ol style="list-style-type: decimal">
<li>面向流程拆分
<ul>
<li>修改范围有限，大多数情况只需修改单层逻辑。<br />
</li>
<li>例如，在学生信息管理系统中，将存储层从 MySQL 扩展为同时支持 MySQL 和 Oracle，只需修改存储层和数据层，无需更改展示层和业务层。</li>
</ul></li>
<li>面向服务拆分
<ul>
<li>新增服务或扩展现有服务时，只需改动相关服务。<br />
</li>
<li>例如，为注册服务增加“学号注册”功能，只需修改注册服务和登录服务，其他服务无需改动。</li>
</ul></li>
<li>面向功能拆分
<ul>
<li>扩展单一功能时，不会影响其他功能模块。<br />
</li>
<li>例如，为注册服务新增“学号注册”功能，仅需增加注册功能模块，并对登录功能模块作相应调整，其他模块保持不变。</li>
</ul></li>
</ol>
<hr />
</div>
<div id="常见可扩展架构" class="section level3 hasAnchor" number="8.1.7">
<h3><span class="header-section-number">8.1.7</span> 常见可扩展架构<a href="可拓展架构.html#常见可扩展架构" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>根据拆分方式的不同，典型的可扩展架构包括：
- 分层架构（面向流程拆分）。<br />
- SOA 或微服务架构（面向服务拆分）。<br />
- 微内核架构（面向功能拆分）。</p>
<p>这些架构并非互斥，而是可以组合使用。例如，学生管理系统可以采用如下混合设计：
- 整体系统采用微服务架构，拆分为注册服务、登录服务、信息管理服务等。
- 注册服务内部采用分层架构。
- 登录服务内部采用微内核架构，按功能进一步拆分。</p>
<hr />
<p>相比高性能和高可用架构模式在过去几十年的迅猛发展，可扩展架构模式的进步显得较为缓慢。虽然最近几年微服务架构的兴起成为可扩展架构的一个重要亮点，但它也在一定程度上引发了一种盲目崇拜。许多人谈到可扩展架构时必谈微服务，甚至将其视为架构设计的万能解决方案。不论是高性能场景还是高可用场景，都试图引入微服务，这种“大炮打蚊子”的做法经常背离了架构设计的“合适性原则”和“简单性原则”。</p>
<p>为帮助大家在实践中更有效地设计可扩展架构，本文将介绍几种常见的可扩展架构模式，包括分层架构、SOA（面向服务架构）以及后续的微服务架构，逐一分析它们的关键特点及优缺点。</p>
<hr />
</div>
</div>
<div id="分层架构" class="section level2 hasAnchor" number="8.2">
<h2><span class="header-section-number">8.2</span> 分层架构<a href="可拓展架构.html#分层架构" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>分层架构（Layered Architecture），也称为 N 层架构，是最常见的架构模式之一，其中 <span class="math inline">\(N\)</span> 通常至少为 2 层，例如 C/S 架构（客户端/服务器）和 B/S 架构（浏览器/服务器）。常见的分层架构包括三层架构（例如 MVC、MVP 架构）、四层架构，而五层及以上架构通常仅适用于复杂系统，例如操作系统内核架构。</p>
<div id="分层架构的多样性" class="section level3 hasAnchor" number="8.2.1">
<h3><span class="header-section-number">8.2.1</span> 分层架构的多样性<a href="可拓展架构.html#分层架构的多样性" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>分层架构的实现可以基于不同的划分对象和维度，常见方式如下：</p>
<div id="cs-架构和-bs-架构" class="section level4 hasAnchor" number="8.2.1.1">
<h4><span class="header-section-number">8.2.1.1</span> 1. C/S 架构和 B/S 架构<a href="可拓展架构.html#cs-架构和-bs-架构" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><p>划分对象：整个业务系统<br />
</p></li>
<li><p>划分维度：用户交互<br />
</p></li>
<li><p>特点：将与用户交互的部分独立为一层（如客户端或浏览器），后台支撑逻辑作为另一层（如服务器）。<br />
示意图：</p>
<pre><code>客户端 &lt;--&gt; 服务器
浏览器 &lt;--&gt; 服务器</code></pre></li>
</ul>
</div>
<div id="mvc-和-mvp-架构" class="section level4 hasAnchor" number="8.2.1.2">
<h4><span class="header-section-number">8.2.1.2</span> 2. MVC 和 MVP 架构<a href="可拓展架构.html#mvc-和-mvp-架构" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><p>划分对象：单个业务子系统<br />
</p></li>
<li><p>划分维度：职责划分<br />
</p></li>
<li><p>特点：不同层次处理不同的职责，层与层之间的依赖关系更加灵活。例如 MVC 中，模型 (Model)、视图 (View)、控制器 (Controller) 可以彼此交互，架构示意如下：</p>
<pre><code>View &lt;--&gt; Controller &lt;--&gt; Model</code></pre></li>
</ul>
</div>
<div id="逻辑分层架构" class="section level4 hasAnchor" number="8.2.1.3">
<h4><span class="header-section-number">8.2.1.3</span> 3. 逻辑分层架构<a href="可拓展架构.html#逻辑分层架构" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><p>划分对象：单个子系统或整个系统<br />
</p></li>
<li><p>划分维度：职责划分<br />
</p></li>
<li><p>特点：逻辑分层架构强调自顶向下的依赖，各层之间是严格的单向依赖。例如，TCP/IP 协议栈或操作系统内核架构。<br />
示例：典型的 J2EE 系统逻辑分层架构如下：</p>
<pre><code>展示层 &lt;--&gt; 业务层 &lt;--&gt; 数据层 &lt;--&gt; 持久化层</code></pre></li>
</ul>
<hr />
</div>
</div>
<div id="分层架构的设计核心" class="section level3 hasAnchor" number="8.2.2">
<h3><span class="header-section-number">8.2.2</span> 分层架构的设计核心<a href="可拓展架构.html#分层架构的设计核心" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>无论采取何种分层方式，分层架构设计的核心是层次间的清晰边界和明确职责：
1. 边界清晰：每层应独立承担明确的职责，避免功能混杂。例如，展示层专注于 UI 和用户交互，业务层负责逻辑处理，数据层专注数据操作。<br />
2. 避免过度分层：分层过多会导致职责不清。例如，功能分配不明确时，程序员可能对功能归属产生分歧，导致架构混乱，失去分层的意义。</p>
</div>
<div id="分层架构的优势" class="section level3 hasAnchor" number="8.2.3">
<h3><span class="header-section-number">8.2.3</span> 分层架构的优势<a href="可拓展架构.html#分层架构的优势" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>分层架构通过隔离关注点（Separation of Concerns），使系统更容易扩展：
- 隔离关注点：各层仅处理自己的逻辑，减少层间耦合。例如，扩展存储层以支持 MySQL 和 Oracle，无需改动展示层或业务层。<br />
- 强制依赖约束：请求按照层次依次传递，避免跳跃式调用，从而降低系统复杂度。例如，业务层仅依赖数据层，而不直接访问数据库层。</p>
<p>以下是分层架构的典型扩展示例：
- Linux 文件系统扩展：通过抽象一个通用接口层（如 VFS），支持多个文件系统格式（ext3、NTFS 等），无需修改其他层。
- J2EE 架构扩展：通过接口定义（如 DAO 模式），将数据访问逻辑与业务逻辑解耦，实现模块独立扩展。</p>
<hr />
</div>
<div id="分层架构的局限性" class="section level3 hasAnchor" number="8.2.4">
<h3><span class="header-section-number">8.2.4</span> 分层架构的局限性<a href="可拓展架构.html#分层架构的局限性" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li>性能冗余：每层都需要处理请求，增加了调用开销。虽然现代硬件性能提升使这种开销在大多数场景中可以忽略不计，但在高性能要求的场景下可能成为瓶颈。<br />
</li>
<li>潜在冗余实现：某些简单功能（如头像查看）可能需要在每层编写简单的封装逻辑，造成冗余。</li>
</ol>
<p>尽管存在这些问题，为了确保架构的稳定性和一致性，通常不建议跳过分层。例如，在 “查看头像” 功能中，直接从展示层调用数据层虽然能减少冗余代码，但长期来看容易导致层次混乱，破坏扩展性。</p>
<hr />
</div>
</div>
<div id="soa面向服务架构" class="section level2 hasAnchor" number="8.3">
<h2><span class="header-section-number">8.3</span> SOA（面向服务架构）<a href="可拓展架构.html#soa面向服务架构" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>SOA，即 Service-Oriented Architecture，提出于 20 世纪 90 年代，由 Gartner 的分析师 Roy W. Schulte 和 Yefim V. Natis 首次提出。SOA 的设计理念侧重于通过服务化解耦复杂系统，主要应用于传统企业中（如制造业、金融业），以应对以下问题：
1. 重复建设：企业内部的独立系统（如人力资源系统、财务系统）往往重复实现类似功能（如员工管理）。<br />
2. 异构性：不同系统由不同技术栈实现，缺乏统一标准，导致协作困难。<br />
3. 扩展低效：业务复杂度增加后，跨系统协作效率低下，每次新增功能都需协调多个系统进行开发和适配。</p>
<div id="soa-的核心概念" class="section level3 hasAnchor" number="8.3.1">
<h3><span class="header-section-number">8.3.1</span> SOA 的核心概念<a href="可拓展架构.html#soa-的核心概念" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li>服务：
<ul>
<li>业务功能被封装为对外提供的独立服务。<br />
</li>
<li>服务粒度可以粗（如“人力资源管理服务”），也可以细（如“人员基本信息管理服务”）。<br />
</li>
</ul></li>
<li>企业服务总线（ESB）：
<ul>
<li>ESB 连接所有服务，屏蔽系统间的异构性，支持协议转换、数据转换等操作，提升服务互联互通的效率。<br />
</li>
</ul></li>
<li>松耦合：
<ul>
<li>通过标准化接口降低服务间依赖，避免某个服务升级时对其他服务造成影响。</li>
</ul></li>
</ol>
</div>
<div id="soa-的优势" class="section level3 hasAnchor" number="8.3.2">
<h3><span class="header-section-number">8.3.2</span> SOA 的优势<a href="可拓展架构.html#soa-的优势" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li>提升复用率：各服务对外提供标准化接口，降低重复开发成本。<br />
</li>
<li>提高扩展效率：新增业务只需基于现有服务组合，而无需对原系统进行大规模调整。</li>
</ul>
</div>
<div id="soa-的挑战" class="section level3 hasAnchor" number="8.3.3">
<h3><span class="header-section-number">8.3.3</span> SOA 的挑战<a href="可拓展架构.html#soa-的挑战" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li>ESB 的复杂性：
<ul>
<li>ESB 需要支持多种协议（如 HTTP、SOAP、RPC）和数据格式（如 XML、JSON、二进制），导致实现和维护成本高。<br />
</li>
<li>当 ESB 处理的消息量过大时，可能成为系统瓶颈。</li>
</ul></li>
<li>服务松耦合的难度：
<ul>
<li>实现完全向后兼容的服务设计需要精心规划，稍有不慎可能导致服务间的耦合程度增加。</li>
</ul></li>
</ol>
</div>
<div id="soa-的典型架构" class="section level3 hasAnchor" number="8.3.4">
<h3><span class="header-section-number">8.3.4</span> SOA 的典型架构<a href="可拓展架构.html#soa-的典型架构" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>下图展示了 SOA 架构的基本框架：<br />
- 每个服务通过标准化接口连接到 ESB，ESB 负责协议和数据格式的转换，确保异构服务间的无缝连接。</p>
<div class="float">
<img src="example.jpg" alt="SOA 架构示意图" />
<div class="figcaption">SOA 架构示意图</div>
</div>
</div>
<div id="soa-的局限性" class="section level3 hasAnchor" number="8.3.5">
<h3><span class="header-section-number">8.3.5</span> SOA 的局限性<a href="可拓展架构.html#soa-的局限性" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li>复杂度高：SOA 的引入往往意味着需要全面改造现有系统，对于中小型企业或简单业务场景，成本可能过高。<br />
</li>
<li>性能开销：由于涉及大量协议和数据格式转换，ESB 的性能瓶颈可能成为系统扩展的障碍。</li>
</ul>
<hr />
</div>
</div>
<div id="微服务炙手可热的架构设计理念" class="section level2 hasAnchor" number="8.4">
<h2><span class="header-section-number">8.4</span> 微服务：炙手可热的架构设计理念<a href="可拓展架构.html#微服务炙手可热的架构设计理念" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>微服务（Microservices）是近年来备受推崇的架构设计模式，广泛应用于现代软件开发。然而，大多数人认为微服务概念由 Martin Fowler 提出，其实并非如此。微服务的历史远早于 Martin Fowler 的系统化阐述（原文：<a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a>）。尽管如此，Martin Fowler 对微服务的推广功不可没，他的理论推动了这一理念的普及。</p>
<p>为了更清晰地理解微服务的发展脉络，我们可以参考维基百科中的微服务历史（<a href="https://en.wikipedia.org/wiki/Microservices#History">https://en.wikipedia.org/wiki/Microservices#History</a>）：</p>
<ol style="list-style-type: decimal">
<li>2005年：Dr. Peter Rodgers 在 Web Services Edge 大会上提出了“Micro-Web-Services”的概念。</li>
<li>2011年：一个软件架构工作组首次使用“microservice”一词来描述一种架构模式。</li>
<li>2012年：该工作组正式确定“microservice”作为这种架构的命名。</li>
<li>2012年：ThoughtWorks 的 James Lewis 在 QCon San Francisco 上发表了关于微服务的演讲。</li>
<li>2014年：James Lewis 与 Martin Fowler 合著了一篇详细阐述微服务的文章，奠定了微服务的理论体系。</li>
</ol>
<hr />
<div id="微服务与-soa-的关系" class="section level3 hasAnchor" number="8.4.1">
<h3><span class="header-section-number">8.4.1</span> 微服务与 SOA 的关系<a href="可拓展架构.html#微服务与-soa-的关系" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>微服务不可避免地被拿来与 SOA（面向服务架构）比较，因为两者都包含“服务”的概念。常见的疑问包括：
- 微服务与 SOA 有何异同？
- 为什么在 SOA 已存在的情况下还要提出微服务？
- 两者是否可以互相替代？</p>
<p>这几个问题是理解微服务的关键。如果只是盲目跟风使用微服务，可能无法发挥其优势，甚至适得其反。以下是业界关于两者关系的几种观点：</p>
<div id="微服务是-soa-的一种实现方式" class="section level4 hasAnchor" number="8.4.1.1">
<h4><span class="header-section-number">8.4.1.1</span> 1. 微服务是 SOA 的一种实现方式<a href="可拓展架构.html#微服务是-soa-的一种实现方式" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>这一观点认为，SOA 是一种抽象的架构理念，而微服务是其具体的实现形式。比如：
- 微服务可以被视为使用 HTTP RESTful 协议实现的轻量化 SOA。
- 在单一系统中实现的 SOA 架构即为微服务。
- 微服务是更细粒度的 SOA。</p>
<p>这种观点的架构示意如下：</p>
<p>SOA</p>
<pre><code>服务粒度较大，通常通过 ESB 实现。  </code></pre>
<p>微服务</p>
<pre><code>服务粒度更细，通常使用 RESTful 或 RPC 协议实现。  </code></pre>
</div>
<div id="微服务是去掉-esb-后的-soa" class="section level4 hasAnchor" number="8.4.1.2">
<h4><span class="header-section-number">8.4.1.2</span> 2. 微服务是去掉 ESB 后的 SOA<a href="可拓展架构.html#微服务是去掉-esb-后的-soa" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>另一些观点认为，SOA 中广为诟病的 ESB（企业服务总线）是架构的复杂、低效之源。微服务通过移除 ESB，将其通信方式简化为轻量级的 HTTP 或 RPC，从而大大降低了实现复杂度。</p>
<p>传统 SOA</p>
<pre><code>[服务A] &lt;--&gt; [ESB] &lt;--&gt; [服务B]</code></pre>
<p>微服务</p>
<pre><code>[服务A] &lt;--&gt; [服务B]  
（无中心化 ESB）</code></pre>
</div>
<div id="微服务与-soa-是两种本质不同的架构理念" class="section level4 hasAnchor" number="8.4.1.3">
<h4><span class="header-section-number">8.4.1.3</span> 3. 微服务与 SOA 是两种本质不同的架构理念<a href="可拓展架构.html#微服务与-soa-是两种本质不同的架构理念" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>这一观点认为，虽然微服务和 SOA 都聚焦于“服务”概念，但其核心理念存在显著差异。两者的主要不同体现在：
- 是否依赖 ESB。
- 服务粒度的大小。
- 架构设计目标的侧重点。</p>
<p>两者的交集在于都强调“服务”作为架构的基础，但其实际实施方式和应用场景却完全不同。</p>
<hr />
</div>
</div>
<div id="soa-与微服务的主要区别" class="section level3 hasAnchor" number="8.4.2">
<h3><span class="header-section-number">8.4.2</span> SOA 与微服务的主要区别<a href="可拓展架构.html#soa-与微服务的主要区别" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>通过对比具体做法，可以更清晰地理解 SOA 和微服务的异同。</p>
<table>
<colgroup>
<col width="13%" />
<col width="44%" />
<col width="41%" />
</colgroup>
<thead>
<tr class="header">
<th>对比维度</th>
<th>SOA</th>
<th>微服务</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>服务粒度</td>
<td>粗粒度，服务通常是较大的业务模块，如“员工管理”</td>
<td>细粒度，服务进一步拆分，如“员工考勤管理”</td>
</tr>
<tr class="even">
<td>通信方式</td>
<td>依赖重量级的 ESB，支持多种协议与消息格式</td>
<td>轻量化通信，使用 RESTful 或 RPC 协议</td>
</tr>
<tr class="odd">
<td>交付模式</td>
<td>注重兼容性，无特别交付要求</td>
<td>强调快速交付，需配合自动化测试与持续集成</td>
</tr>
<tr class="even">
<td>应用场景</td>
<td>企业级系统：异构且复杂，改造成本高</td>
<td>互联网系统：轻量化、快速变化</td>
</tr>
</tbody>
</table>
<p>Martin Fowler 在微服务文章中提到的关键词 small、lightweight、automated，正是微服务区别于 SOA 的核心特征。</p>
<hr />
</div>
<div id="微服务的陷阱与挑战" class="section level3 hasAnchor" number="8.4.3">
<h3><span class="header-section-number">8.4.3</span> 微服务的陷阱与挑战<a href="可拓展架构.html#微服务的陷阱与挑战" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>尽管微服务被视为一种现代化架构的优秀选择，但在实际应用中，许多团队在实施微服务时陷入了各种陷阱：</p>
<div id="服务划分过细复杂度激增" class="section level4 hasAnchor" number="8.4.3.1">
<h4><span class="header-section-number">8.4.3.1</span> 1. 服务划分过细，复杂度激增<a href="可拓展架构.html#服务划分过细复杂度激增" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>问题：服务划分过细确实降低了单个服务的复杂度，但系统整体复杂度呈指数级增长。<br />
</li>
<li>示例：系统从 3 个服务扩展到 10 个服务后，服务间关系数量从 3 个增加到 45 个，复杂度大幅上升。</li>
</ul>
</div>
<div id="服务数量过多团队效率下降" class="section level4 hasAnchor" number="8.4.3.2">
<h4><span class="header-section-number">8.4.3.2</span> 2. 服务数量过多，团队效率下降<a href="可拓展架构.html#服务数量过多团队效率下降" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>问题：团队规模较小（如 5 ~ 6 人）却拆分了 30 多个微服务，每人需维护 5 个以上服务，导致协作成本和开发效率大幅下降。<br />
</li>
<li>影响：
<ul>
<li>开发时需要频繁切换项目、设计接口。</li>
<li>测试时需准备多个环境、测试大量接口。</li>
<li>部署时操作多个服务，复杂度显著增加。</li>
</ul></li>
</ul>
</div>
<div id="调用链过长性能下降" class="section level4 hasAnchor" number="8.4.3.3">
<h4><span class="header-section-number">8.4.3.3</span> 3. 调用链过长，性能下降<a href="可拓展架构.html#调用链过长性能下降" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>问题：微服务间通过网络通信，调用链过长导致显著性能损耗。<br />
</li>
<li>示例：一次请求需经过 6 次微服务调用，每次调用平均消耗 50 毫秒，总响应时间达 300 毫秒，难以满足高性能场景需求。</li>
</ul>
</div>
<div id="故障定位困难" class="section level4 hasAnchor" number="8.4.3.4">
<h4><span class="header-section-number">8.4.3.4</span> 4. 故障定位困难<a href="可拓展架构.html#故障定位困难" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>问题：服务数量多、调用链复杂，导致故障定位极具挑战性。<br />
</li>
<li>示例：
<ul>
<li>服务 C 的数据库出现慢查询，导致服务 A 和服务 B 均报错。</li>
<li>故障定位需逐层排查，可能耗费数小时。</li>
</ul></li>
</ul>
</div>
<div id="缺乏自动化支撑难以快速交付" class="section level4 hasAnchor" number="8.4.3.5">
<h4><span class="header-section-number">8.4.3.5</span> 5. 缺乏自动化支撑，难以快速交付<a href="可拓展架构.html#缺乏自动化支撑难以快速交付" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>问题：微服务的快速交付依赖自动化测试、部署和监控。如果没有这些支撑，开发成本和运维复杂度将大幅上升。</li>
</ul>
</div>
<div id="服务治理不足系统管理混乱" class="section level4 hasAnchor" number="8.4.3.6">
<h4><span class="header-section-number">8.4.3.6</span> 6. 服务治理不足，系统管理混乱<a href="可拓展架构.html#服务治理不足系统管理混乱" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>问题：随着微服务数量增加，服务路由、故障隔离、服务注册等问题变得难以管理。缺乏服务治理系统的支持，轻量化的微服务反而会发展成复杂的系统。</li>
</ul>
<hr />
</div>
</div>
<div id="总结-4" class="section level3 hasAnchor" number="8.4.4">
<h3><span class="header-section-number">8.4.4</span> 总结<a href="可拓展架构.html#总结-4" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>微服务和 SOA 本质上是两种不同的架构设计理念，各有优劣，适用于不同场景：
- SOA：适合复杂、异构的企业级系统，侧重于兼容性和稳定性。<br />
- 微服务：适合轻量化、快速变化的互联网系统，强调敏捷和快速交付。</p>
<p>选择微服务时，需结合团队规模、业务需求和技术能力，避免因盲目实施而陷入常见的架构陷阱。微服务不是“银弹”，但在合适的场景中可以大放异彩。</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="高可用存储架构.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="架构模版.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/USERNAME/REPO/edit/BRANCH/07-references.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf", "_main.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
